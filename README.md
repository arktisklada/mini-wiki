# Latest plane crash

## Installation

Assuming latest stable node.js is installed, clone this repository then run

```
npm install
node wiki.js
```

Navigate to `http://localhost:3000`

---

## Notes

For viewing the article, I implemented a cache-control lifespan.
This is intended to be honored by a Varnish caching system.
I went with an assumption that despite the frequency of updates, a delay between cache expiration and server re-rendering is acceptable.
20,000 different requests do not necessarily need to receive unique responses generated by a server.

For editing, I found that there were 2 situations:
  1. There is only one editor at a time and they edit REALLY fast (1/10th of a second for each edit) -- highly unlikely!
  2. Multiple people are editing the same article but they may have started with different versions of the article.  
    I considered this more likely and implemented a catch for whoever is editing the most up-to-date revision gets his/her revisions saved.
    Everyone else will need to re-edit.

Given the frequency of editing and the potential length of the view/html directory,
I implemented a Redis caching strategy to log the most recent revision.
This value is also used when responding with the appropriate article view.

Further considerations
  - For editing, implementing the ability to identify a "diff" between revisions and incoming edits
  - A nicer way of editing the article.
    Perhaps a markdown-style syntax (with UI buttons for styles and formatting) that would be converted to HTML before writing to file?
  - A more intelligent lifespan for each page's cache.
    This could be based on the frequency of edits, with a fallback to the timestamp of the most recent edit.
    For example, I've used Memcached for page caching where each page's cache key is dependent on a last-modified timestamp.
    In this situation, the key would incorporate the latest revision value (/Latest_plane_crash/23984723987).
  - From a RESTful routing point of view, the edit should submit to a PUT endpoint, not POST
  - I would also like to explore further the idea of implementing a front-end JS framework or just vanilla AJAX.
    This would reduce the server-side render time and reduce the size of data passed between server and client (JSON).
  - Security is a concern, where only authenticated users should be able to submit.
    Beyond user authentication, I would also advocate for sanitizing the incoming content for any malicious code or foul language.